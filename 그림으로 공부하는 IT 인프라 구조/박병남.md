# 1장, 인프라 아키텍처를 살펴보자
- p8) 분할형 아키텍처는 표준 OS나 개발 언어를 이용하기 때문에 '오픈 시스템' 이라고 불린다 (?)
  - 표준 OS나 개발 언어를 사용한다는게 무슨 말?


# 2장, 서버를 열어 보자

- Interrupt
- p30) 일반적으로 캐시 메모리가 커질수록 액세스 속도가 느려진다??
- 라이트백 vs 라이트스루
  - 라이트백은 캐시까지만 접근
  - 라이트 스루는 캐시와 디스크에 접근
- 기가트랜스퍼?


# 3장, 3계층형 시스템을 살펴보자
- 프로세스 vs 스레드
![프로세스](https://user-images.githubusercontent.com/57394605/129068861-c7a04e6e-8333-4aaa-8400-0a5c37569a0b.png)
![스레드](https://user-images.githubusercontent.com/57394605/129068919-538cd088-709f-4e06-9a05-0e1a2dce6f1a.png)
- OS
  - 시스템 콜 인터페이스
  - 프로세스 관리 (CPU 스케줄링)
  - 메모리 관리 (페이징 교체 전략)
  - 네트워크 스택
  - 파일 시스템 관리
  - 장치 드라이버
- [가상화](https://nearhome.tistory.com/79)


# 4장, 인프라를 지탱하는 기본 이론
- p80) 하나의 CPU 코어를 동시에 사용할 수 있는 것은 1스레드 이다 ??
- 웹 서버에는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리
- WAS서버 (AP서버) 에서는 JVM 프로세스가 하나이지만 멀티스레드를 사용해 병렬 처리
- 동기 함수
  - 그 함수가 반환될 때 까지 해당 컨텍스트가 진행되지 않고 기다리다가 반환되고 나서야 컨텍스트가 진행되는 항수
  - 사실 컨텍스트를 기다리는 것이 아니라 해당 컨텍스트가 함수의 내용을 직접 처리하기 때문에 호출한 입장에서 보면 기다리는 것 처럼 보이는 것
- 비동기 함수
  - 새로운 작업 스레드를 생성하고 생성된 스레드의 컨텍스트가 진행
  - 함수를 호출한 컨텍스트는 함수를 호출하자마자 함수의 반환을 받고 계속 진행.
  - 비동기 함수는 언제 실제로 종료될지 모르기 때문에 함수의 반환이 아닌 다른 기법을 사용. 폴링이나 메시지 콜백함수 기법을 통해 함수 종료를 알 수 있음
    - 폴링 방식: 상태를 주기적으로 체크하여 상태에 따라서 처리
    - 메시지 방식: 메시지가 전달되면 해당 메시지에 따라서 처리하는 방식
- 배타적 제어? 선점? 같은말인가?
- stateless and stateful 생소했음
- p.116 이해가 안됌.
- b트리
  - ![b트리](https://user-images.githubusercontent.com/57394605/129082325-af88a7aa-cf5b-45bb-aebc-12408ed661e1.png)
- p 124) 범위검색에 약하다..?
- 

